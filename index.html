<!DOCTYPE html>
<html>
<head>
  <title>Babylon.js GLB Viewer - Extended Camera Controls</title>
 <link rel="stylesheet" href="index.css">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="like_button.js"></script>
  <script src="red.js"></script>
  <script src="orange.js"></script>
  <script src="chart.js"></script>
  <script>        const chart = new ChartComponent();
        chart.componentDidMount();</script>
</head>
<body>
  <div id="controlPanel" class="bottom-controls">
    <div class="file-dropdown">
        <div class="upload-btn-container">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                <i class="fa fa-cloud-upload"></i>
                <span>Upload Model</span>
            </button>
            <input type="file" id="fileInput" accept=".glb,.obj,.gltf" hidden />
        </div>
        <div class="dropdown-content">
            <!-- <input type="file" id="fileInput" accept=".glb,.obj,.gltf" hidden />
            <label for="fileInput" class="file-option"> -->
                <i class="fa fa-cube"></i>  GLB/GLTF/OBJ Model

            <!-- <input type="file" id="objFileInput" accept=".obj" hidden />
            <label for="objFileInput" class="file-option">
                <i class="fa fa-object-group"></i> OBJ Model -->

        </div>
    </div>
</div>

<!-- Add this new separate control buttons container -->
<div class="control-buttons-container">
    <div class="control-buttons">
        <button id="resetCamera" class="icon-btn" title="Reset Camera Position&#10;Click to center view on model">
            <i class="fa fa-refresh"></i>
        </button>
        <button id="toggleInspector" class="icon-btn" title="Toggle Scene Inspector&#10;Click to show/hide debugging tools">
            <i class="fa fa-wrench"></i>
        </button>
        <button id="switchCamera" class="icon-btn" title="Switch Camera Mode&#10;Click to toggle between Arc Rotate and Universal camera">
            <i class="fa fa-video-camera"></i>
        </button>
        <button id="initiateFPP" class="icon-btn" title="First Person Mode&#10;Click to enter first-person perspective">
            <i class="fa fa-street-view"></i>
        </button>
        <button id="moveUp" class="icon-btn" title="Move Up&#10;Click and hold to move camera upward">
            <i class="fa fa-arrow-up"></i>
        </button>
        <button id="moveDown" class="icon-btn" title="Move Down&#10;Click and hold to move camera downward">
            <i class="fa fa-arrow-down"></i>
        </button>
    </div>
</div>

  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  <div id="propertyPanel"></div>
  <div id="meshList">
    <h3 id="meshListToggle">Asset list ▸</h3>
    <div id="meshListContent"></div>
  </div>
  <div id="fpsCounter">FPS: 0</div>
  <canvas id="renderCanvas"></canvas>
  <input type="file" id="objFileInput" accept=".obj" style="display:none">
  <button id="loadObjBtn">Load OBJ Model</button>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46156385-1', 'cssscript.com');
  ga('send', 'pageview');
    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);
      const fileInput = document.getElementById("fileInput");
      const resetCameraBtn = document.getElementById("resetCamera");
      const toggleInspectorBtn = document.getElementById("toggleInspector");
      const switchCameraBtn = document.getElementById("switchCamera");
      const initiateFPPBtn = document.getElementById("initiateFPP");
      const moveUpBtn = document.getElementById("moveUp");
      const moveDownBtn = document.getElementById("moveDown");
      const fpsCounter = document.getElementById("fpsCounter");
      const propertyPanel = document.getElementById("propertyPanel");
      const meshListPanel = document.getElementById("meshList");
      const meshListContent = document.getElementById("meshListContent");
      const loadObjBtn = document.getElementById('loadObjBtn');
      const objFileInput = document.getElementById('objFileInput');
      
      const meshListToggle = document.getElementById("meshListToggle");
      const meshList = document.getElementById("meshList");

      // Add click handler for toggle
      meshListToggle.addEventListener('click', () => {
          meshList.classList.toggle('expanded');
          const arrow = meshListToggle.textContent.includes('▾') ? '▸' : '▾';
          meshListToggle.textContent = `Asset List ${arrow}`;
      });

      let currentScene = null;
      let currentCamera = null;
      let moveInterval = null;
      
      const meshSelectedEvent = new CustomEvent('meshSelected', { detail: { properties: null } });
      
      function calculateModelBounds(meshes) {
        let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        meshes.forEach(mesh => {
          const bbox = mesh.getBoundingInfo().boundingBox;
          min = BABYLON.Vector3.Minimize(min, bbox.minimum);
          max = BABYLON.Vector3.Maximize(max, bbox.maximum);
        });
        return {
          center: BABYLON.Vector3.Center(min, max),
          size: max.subtract(min)
        };
      }
      
      function createMeshOverlay(mesh) {
    const overlayDiv = document.createElement('div');
    overlayDiv.className = 'capsule_component_container';
    overlayDiv.style.position = 'absolute';
    overlayDiv.style.zIndex = '1200';
    document.body.appendChild(overlayDiv);

    // Store reference to root for cleanup
    const root = ReactDOM.createRoot(overlayDiv);
    root.render(React.createElement(CapsuleComponent, {}));

    // Add click handler to replace capsule with menu
    overlayDiv.addEventListener('click', () => {
        const menuNav = document.createElement('nav');
        menuNav.className = 'menu';
        menuNav.innerHTML = `
            <input type="checkbox" href="#" class="menu-open" name="menu-open" id="menu-open-${mesh.uniqueId}" checked />
            <label class="menu-open-button" for="menu-open-${mesh.uniqueId}"> 
                <span class="lines line-1"></span> 
                <span class="lines line-2"></span> 
                <span class="lines line-3"></span> 
            </label>
            <a href="#" class="menu-item item-1"> 
                <i class="fa fa-info"></i> 
            </a> 
            <a href="#" class="menu-item item-2"> 
                <i class="fa fa-coffee"></i> 
            </a> 
            <a href="#" class="menu-item item-3"> 
                <i class="fa fa-heart"></i>
            </a> 
            <a href="#" class="menu-item item-4"> 
                <i class="fa fa-microphone"></i> 
            </a> 
            <a href="#" class="menu-item item-5"> 
                <i class="fa fa-star"></i> 
            </a> 
            <a href="#" class="menu-item item-6"> 
                <i class="fa fa-diamond"></i> 
            </a>
        `;

        menuNav.style.position = 'absolute';
        menuNav.style.left = overlayDiv.style.left;
        menuNav.style.top = overlayDiv.style.top;
        menuNav.style.zIndex = overlayDiv.style.zIndex;

        // Replace capsule with menu
        document.body.removeChild(overlayDiv);
        document.body.appendChild(menuNav);

        const positionUpdateHandler = currentScene.registerBeforeRender(() => {
            if (mesh && menuNav) {
                const meshPosition = mesh.getBoundingInfo().boundingBox.centerWorld;
                const screenPosition = BABYLON.Vector3.Project(
                    meshPosition,
                    BABYLON.Matrix.Identity(),
                    currentScene.getTransformMatrix(),
                    currentCamera.viewport.toGlobal(
                        engine.getRenderWidth(),
                        engine.getRenderHeight()
                    )
                );

                menuNav.style.left = `${screenPosition.x -770}px`;
                menuNav.style.top = `${screenPosition.y - 50}px`;
            }
        });

        // Function to restore capsule
        const restoreCapsule = () => {
            document.body.removeChild(menuNav);
            currentScene.unregisterBeforeRender(positionUpdateHandler);
            
            // Recreate capsule
            const newOverlay = createMeshOverlay(mesh);
            
            // Position it immediately
            const meshPosition = mesh.getBoundingInfo().boundingBox.centerWorld;
            const screenPosition = BABYLON.Vector3.Project(
                meshPosition,
                BABYLON.Matrix.Identity(),
                currentScene.getTransformMatrix(),
                currentCamera.viewport.toGlobal(
                    engine.getRenderWidth(),
                    engine.getRenderHeight()
                )
            );

            newOverlay.style.left = `${screenPosition.x}px`;
            newOverlay.style.top = `${screenPosition.y - 70}px`;
        };

        // Add click handler for menu-open-button
        const menuOpenButton = menuNav.querySelector('.menu-open-button');
        menuOpenButton.addEventListener('click', (e) => {
            e.preventDefault();
            restoreCapsule();
        });

        // Add click handlers for menu items
        menuNav.querySelectorAll('.menu-item').forEach((item, index) => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                if (index === 0) { // Info icon clicked
                    restoreCapsule();
                } else {
                    console.log('Menu item clicked:', e.target.className);
                }
            });
        });
    });

    // Update overlay position in render loop
    currentScene.registerBeforeRender(() => {
        if (mesh && overlayDiv) {
            const meshPosition = mesh.getBoundingInfo().boundingBox.centerWorld;
            const screenPosition = BABYLON.Vector3.Project(
                meshPosition,
                BABYLON.Matrix.Identity(),
                currentScene.getTransformMatrix(),
                currentCamera.viewport.toGlobal(
                    engine.getRenderWidth(),
                    engine.getRenderHeight()
                )
            );

            overlayDiv.style.left = `${screenPosition.x}px`;
            overlayDiv.style.top = `${screenPosition.y - 70}px`;
        }
    });

    return overlayDiv;
}

function createRedMeshOverlay(mesh) {
  // Create a div element to hold the React component
  const overlayDiv = document.createElement('div');
  overlayDiv.className = 'capsule_component_containerred';
  overlayDiv.style.position = 'absolute';
  overlayDiv.style.zIndex = '1200';
  document.body.appendChild(overlayDiv);

  // Create React root and render component
  const root = ReactDOM.createRoot(overlayDiv);
  root.render(React.createElement(RedCapsuleComponent, {}));

  // Update overlay position in render loop
  currentScene.registerBeforeRender(() => {
    if (mesh && overlayDiv) {
      const meshPosition = mesh.getBoundingInfo().boundingBox.centerWorld;
      const screenPosition = BABYLON.Vector3.Project(
        meshPosition,
        BABYLON.Matrix.Identity(),
        currentScene.getTransformMatrix(),
        currentCamera.viewport.toGlobal(
          engine.getRenderWidth(),
          engine.getRenderHeight()
        )
      ); 
      overlayDiv.style.left = `${screenPosition.x}px`;
      overlayDiv.style.top = `${screenPosition.y - 100}px`; // Offset above the mesh
    }
  });

  return overlayDiv;
}
function createOrangeMeshOverlay(mesh) {
  // Create a div element to hold the React component
  const overlayDiv = document.createElement('div');
  overlayDiv.className = 'capsule_component_containerred-orange';   
  overlayDiv.style.position = 'absolute';
  overlayDiv.style.zIndex = '1200';
  document.body.appendChild(overlayDiv);

  // Create React root and render component
  const root = ReactDOM.createRoot(overlayDiv);
  root.render(React.createElement(orangeCapsuleComponent, {}));

  // Update overlay position in render loop
  currentScene.registerBeforeRender(() => {
    if (mesh && overlayDiv) {
      const meshPosition = mesh.getBoundingInfo().boundingBox.centerWorld;
      const screenPosition = BABYLON.Vector3.Project(
        meshPosition,
        BABYLON.Matrix.Identity(),
        currentScene.getTransformMatrix(),
        currentCamera.viewport.toGlobal(
          engine.getRenderWidth(),
          engine.getRenderHeight()
        )
      );

      overlayDiv.style.left = `${screenPosition.x}px`;
      overlayDiv.style.top = `${screenPosition.y - 60}px`; // Offset above the mesh
    }
  });

  return overlayDiv;
}

// Replace the applyCustomGlow function with this version that uses CSS filters

function applyCustomGlow(mesh, color) {
    // Create a new glow layer specific to this mesh
    const glowName = "glow_" + mesh.uniqueId;
    
    // Remove existing glow layer if it exists
    const existingGlow = currentScene.getGlowLayerByName(glowName);
    if (existingGlow) {
        existingGlow.dispose();
    }
    
    const glowLayer = new BABYLON.GlowLayer(glowName, currentScene, {
        mainTextureFixedSize: 1024,
        blurKernelSize: 32,
        mainTextureSamples: 4
    });

    // Convert hex color to Babylon.js Color3
    const c = BABYLON.Color3.FromHexString(color);
    
    // Set the glow parameters
    glowLayer.intensity = 0.45;
    
    // Add only this specific mesh
    glowLayer.addIncludedOnlyMesh(mesh);
    
    // Set custom emissive color for the glow
    glowLayer.customEmissiveColorSelector = function(meshRef, subMesh, material, result) {
        result.set(c.r, c.g, c.b);
        return result;
    };
}

      function getMeshProperties(mesh) {
        const pos = mesh.position;
        const rot = mesh.rotation;
        const scale = mesh.scaling;
        const bbox = mesh.getBoundingInfo().boundingBox;
        const properties = {
          "Basic Properties": {
            "Name": mesh.name,
            "Unique ID": mesh.uniqueId,
            "Visible": mesh.isVisible,
            "Enabled": mesh.isEnabled(),
            "Pickable": mesh.isPickable
          },
          "Transform": {
            "Position": `X: ${pos.x.toFixed(3)}, Y: ${pos.y.toFixed(3)}, Z: ${pos.z.toFixed(3)}`,
            "Rotation": `X: ${rot.x.toFixed(3)}, Y: ${rot.y.toFixed(3)}, Z: ${rot.z.toFixed(3)}`,
            "Scaling": `X: ${scale.x.toFixed(3)}, Y: ${scale.y.toFixed(3)}, Z: ${scale.z.toFixed(3)}`
          },
          "Geometry": {
            "Vertices Count": mesh.getTotalVertices(),
            "Faces Count": (mesh.getTotalIndices() / 3) || 0,
            "Bounding Box Min": `X: ${bbox.minimum.x.toFixed(3)}, Y: ${bbox.minimum.y.toFixed(3)}, Z: ${bbox.minimum.z.toFixed(3)}`,
            "Bounding Box Max": `X: ${bbox.maximum.x.toFixed(3)}, Y: ${bbox.maximum.y.toFixed(3)}, Z: ${bbox.maximum.z.toFixed(3)}`
          }
        };
        if (mesh.material) {
          properties["Material"] = {
            "Name": mesh.material.name,
            "Type": mesh.material.getClassName(),
            "Alpha": mesh.material.alpha
          };
        }
        if (mesh.metadata) {
          properties["Custom Metadata"] = mesh.metadata;
        }
        return properties;
      }
      
      function updatePropertyPanel(properties) {
        if (!properties) {
          propertyPanel.style.display = "none";
          propertyPanel.innerHTML = "";
          return;
        }
        propertyPanel.style.display = "block";
        propertyPanel.innerHTML = "";
        Object.entries(properties).forEach(([cat, props]) => {
          const catDiv = document.createElement("div");
          catDiv.innerHTML = `<h3>${cat}</h3>`;
          Object.entries(props).forEach(([key, val]) => {
            const row = document.createElement("div");
            row.className = "property-row";
            row.innerHTML = `<span>${key}:</span><span>${val}</span>`;
            catDiv.appendChild(row);
          });
          propertyPanel.appendChild(catDiv);
        });
        const exportBtn = document.createElement("button");
        exportBtn.textContent = "Export Properties";
        exportBtn.className = "btn";
        exportBtn.onclick = () => {
          const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(properties, null, 2));
          const link = document.createElement('a');
          link.setAttribute("href", dataStr);
          link.setAttribute("download", properties["Basic Properties"]["Name"] + "_properties.json");
          document.body.appendChild(link);
          link.click();
          link.remove();
        };
        propertyPanel.appendChild(exportBtn);
        meshSelectedEvent.detail.properties = properties;
        window.dispatchEvent(meshSelectedEvent);
      }
      
      function updateMeshList(meshes) {
        meshListContent.innerHTML = "";
        if (!meshes.length) {
            meshList.style.display = "none";
            return;
        }
        meshList.style.display = "block";
        meshList.classList.add('expanded'); // Start expanded when new meshes are loaded
        meshListToggle.textContent = "Asset List ▾"; // Reset arrow
        
        meshes.forEach(mesh => {
            const item = document.createElement("div");
            item.className = "mesh-item";
            item.textContent = mesh.name;
            item.onclick = () => {
                const pickResult = { hit: true, pickedMesh: mesh };
                currentScene.onPointerDown(null, pickResult);
                
                // Get best view positions
                const viewInfo = getMeshBestView(mesh);
                
                // Animate camera to new position
                if (currentCamera instanceof BABYLON.ArcRotateCamera) {
                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraMove",
                        currentCamera,
                        "target",
                        30,
                        30,
                        currentCamera.target,
                        viewInfo.targetPosition,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );
                    
                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraPosition",
                        currentCamera,
                        "position",
                        30,
                        30,
                        currentCamera.position,
                        viewInfo.cameraPosition,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );
                } else if (currentCamera instanceof BABYLON.UniversalCamera) {
                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraMove",
                        currentCamera,
                        "position",
                        30,
                        30,
                        currentCamera.position,
                        viewInfo.cameraPosition,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );
                    currentCamera.setTarget(viewInfo.targetPosition);
                }
            };
            meshListContent.appendChild(item);
        });
    }
      async function createScene(file = null) {
    if (currentScene) { currentScene.dispose(); }
    const scene = new BABYLON.Scene(engine);
    currentScene = scene;
    
    // Change background color to a darker shade
    scene.clearColor = new BABYLON.Color3(222 / 255, 228 / 255, 231 / 255);

    // Create and configure the environment
    const environmentTexture = new BABYLON.CubeTexture(
        "/example.env",  // You can replace with your own .env file path
        scene
    );
    
    // Create skybox
    const skybox = scene.createDefaultSkybox(environmentTexture, true, 10000, 0.00);
    
    // Enable image processing to make the skybox look better
    const pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, scene);
    if (pipeline) {
        pipeline.imageProcessing.exposure = 0.6;
        pipeline.imageProcessing.contrast = 1.6;
        pipeline.toneMappingEnabled = true;
    }

    // Rest of your existing createScene code...
    const camera = new BABYLON.ArcRotateCamera("arcCam", 0, Math.PI / 3, 10, BABYLON.Vector3.Zero(), scene);
    camera.lowerBetaLimit = 0.1; // Prevents camera from going below the model
camera.upperBetaLimit = Math.PI / 2; // Restricts angle to not go above top view
camera.lowerRadiusLimit = 5;
camera.upperRadiusLimit = 950; 
    camera.attachControl(canvas, true);
    camera.minZ = 0.1;
    currentCamera = camera;
    
    // Update lighting setup
    const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    hemiLight.intensity = 0.5;
    hemiLight.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    hemiLight.specular = new BABYLON.Color3(0.5, 0.5, 0.5);

    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
    dirLight.intensity = 0.15;
    dirLight.position = new BABYLON.Vector3(20, 20, 20);

    // Update default material settings
    scene.onMeshImportedObservable.add((mesh) => {
    if (mesh.material) {
        mesh.material = new BABYLON.StandardMaterial("mat_" + mesh.uniqueId, scene);
        mesh.material.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        mesh.material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);  // Reduced from 0.5
        mesh.material.specularPower = 64;                                  // Increased from 16
        mesh.material.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        mesh.material.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);  // Reduced from 0.1
        mesh.material.backFaceCulling = false;
    }
});

    const light = new BABYLON.HemisphericLight("li∂ght", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    
    const highlightMaterial = new BABYLON.StandardMaterial("hlMat", scene);
    highlightMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0);
    highlightMaterial.emissiveColor = new BABYLON.Color3(0.4, 0.4, 0);
    highlightMaterial.alpha = 0.8;
    
    let loadedMeshes = [];
    
    resetCameraBtn.onclick = () => {
      if (loadedMeshes.length) {
        const { center, size } = calculateModelBounds(loadedMeshes);
        currentCamera.position = new BABYLON.Vector3(
          center.x,
          center.y + size.y,
          center.z + Math.max(size.x, size.y, size.z) * 2
        );
        if (currentCamera instanceof BABYLON.ArcRotateCamera) {
          currentCamera.target = center;
        } else if (currentCamera instanceof BABYLON.UniversalCamera) {
          currentCamera.setTarget(center);
        }
      } else {
        if (currentCamera instanceof BABYLON.ArcRotateCamera) {
          currentCamera.target = BABYLON.Vector3.Zero();
        }
      }
    };
    
    toggleInspectorBtn.onclick = () => {
      if (scene.debugLayer.isVisible()) {
        scene.debugLayer.hide();
      } else {
        scene.debugLayer.show({ embedMode: true });
      }
    };
    
    try {
      let result;
      if (file) {
        result = await BABYLON.SceneLoader.ImportMeshAsync("", "", file, scene);
      }
      if (result) {
        loadedMeshes = result.meshes.filter(m => m.name !== "__root__");
        if (loadedMeshes.length) {
          const bounds = calculateModelBounds(loadedMeshes);
          currentCamera.position = new BABYLON.Vector3(
            bounds.center.x,
            bounds.center.y + bounds.size.y,
            bounds.center.z + Math.max(bounds.size.x, bounds.size.y, bounds.size.z) * 2
          );
          if (currentCamera instanceof BABYLON.ArcRotateCamera) {
            currentCamera.target = bounds.center;
          } else if (currentCamera instanceof BABYLON.UniversalCamera) {
            currentCamera.setTarget(bounds.center);
          }
        }
        updateMeshList(loadedMeshes);
      }
    } catch (error) {
      console.error("Error loading model:", error);
      const errDiv = document.createElement("div");
      errDiv.style.color = "red";
      errDiv.textContent = "Error loading model: " + error.message;
      document.getElementById("controlPanel").appendChild(errDiv);
    }
    
    let highlightedMesh = null;
    let originalMaterial = null;
    
function clearHighlight() {
    if (highlightedMesh) {
        // Change to red material to indicate deselection
        if (originalMaterial) {
            highlightedMesh.material = originalMaterial;
        } else {
            // If no original material, create a default material
            const defaultMaterial = new BABYLON.StandardMaterial("defaultMat", currentScene);
            defaultMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9); // Light gray
            defaultMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            defaultMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
            highlightedMesh.material = defaultMaterial;
        }
        
        // Remove chart if it exists
        if (highlightedMesh.chartComponent) {
            const containers = document.querySelectorAll('.chart-container');
            containers.forEach(container => container.remove());
            highlightedMesh.chartComponent = null;
        }
        
        highlightedMesh = null;
        originalMaterial = null;
    }
}

    
scene.onPointerDown = function (evt, pickResult) {
  if (pickResult.hit) {
    if (highlightedMesh === pickResult.pickedMesh) {
      return;
    }
    
    clearHighlight();
    
    highlightedMesh = pickResult.pickedMesh;
    originalMaterial = highlightedMesh.material;
    
    if (originalMaterial) {
      originalMaterial = originalMaterial.clone("originalMat");
    }
    
    highlightedMesh.material = new BABYLON.StandardMaterial("highlightMat", scene);
    highlightedMesh.material.diffuseColor = new BABYLON.Color3(0.3, 0.6, 1);
    highlightedMesh.material.specularColor = new BABYLON.Color3(1, 1, 1);

  } else {
    // Remove chart when clicking empty space
    if (highlightedMesh && highlightedMesh.chartComponent) {
      const containers = document.querySelectorAll('.chart-container');
      containers.forEach(container => container.remove());
      highlightedMesh.chartComponent = null;
    }
    
    clearHighlight();
    updatePropertyPanel(null);
  }
};
    
    // Add this to your mesh loading completion handler
    scene.onMeshLoaded = function(mesh) {
        if (mesh.material) {
            mesh.material = mesh.material.clone("clonedMat");
        }
    };
    
    engine.runRenderLoop(() => {
      scene.render();
      fpsCounter.textContent = "FPS: " + engine.getFps().toFixed(1);
    });
    
    scene.onDisposeObservable.add(() => {
      loadedMeshes = [];
      meshListPanel.style.display = "none";
    });
    return scene;
  }
      
      // Switch camera between ArcRotateCamera and UniversalCamera
      switchCameraBtn.onclick = () => {
        if (!currentScene || !currentCamera) return;
        const oldCam = currentCamera;
        let newCam;
        if (oldCam instanceof BABYLON.ArcRotateCamera) {
          newCam = new BABYLON.UniversalCamera("univCam", oldCam.position.clone(), currentScene);
          newCam.setTarget(oldCam.target || BABYLON.Vector3.Zero());
          newCam.attachControl(canvas, true);
        } else {
          const target = (oldCam.getTarget && oldCam.getTarget()) || BABYLON.Vector3.Zero();
          const direction = oldCam.position.subtract(target);
          const radius = direction.length();
          const alpha = Math.atan2(direction.z, direction.x);
          const beta = Math.acos(direction.y / radius);
          newCam = new BABYLON.ArcRotateCamera("arcCam", alpha, beta, radius, target, currentScene);
          newCam.lowerBetaLimit = 0.1;
  newCam.upperBetaLimit = Math.PI / 2;
  newCam.lowerRadiusLimit = 5;
  newCam.upperRadiusLimit = 950;
  newCam.attachControl(canvas, true);
          newCam.attachControl(canvas, true);
        }
        currentCamera = newCam;
        oldCam.dispose();
      };
      
      // Initiate FPP: force UniversalCamera mode
      initiateFPPBtn.onclick = () => {
        if (!currentScene || !currentCamera) return;
        if (currentCamera instanceof BABYLON.UniversalCamera) return;
        const oldCam = currentCamera;
        const newCam = new BABYLON.UniversalCamera("univCam", oldCam.position.clone(), currentScene);
        newCam.setTarget(oldCam.target || BABYLON.Vector3.Zero());
        newCam.attachControl(canvas, true);
        currentCamera = newCam;
        oldCam.dispose();
      };
      
      // Long press functionality for moving up & down
      function startMove(direction) {
    if (!currentCamera) return;
    moveInterval = setInterval(() => {
        if (currentCamera instanceof BABYLON.UniversalCamera) {
            currentCamera.position.y += (direction === "up" ? 0.5 : -0.5); // Increased from 0.2
        } else if (currentCamera instanceof BABYLON.ArcRotateCamera) {
            currentCamera.target = currentCamera.target.add(
                new BABYLON.Vector3(0, direction === "up" ? 0.5 : -0.5, 0)
            ); // Increased from 0.2
        }
    }, 16); // Changed from 50 to 16 for smoother movement (60fps)
}
      function stopMove() {
        if (moveInterval) {
          clearInterval(moveInterval);
          moveInterval = null;
        }
      }
      
      // Attach long press events for move up / down buttons
      ["mousedown", "touchstart"].forEach(ev => {
        moveUpBtn.addEventListener(ev, (e) => { e.preventDefault(); startMove("up"); });
        moveDownBtn.addEventListener(ev, (e) => { e.preventDefault(); startMove("down"); });
      });
      ["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(ev => {
        moveUpBtn.addEventListener(ev, stopMove);
        moveDownBtn.addEventListener(ev, stopMove);
      });
      
      // Initialize the scene without any model.
      createScene();
      
      fileInput.addEventListener('change', async (event) => {
  if (event.target.files && event.target.files[0]) {
    const file = event.target.files[0];
    try {
      const result = await BABYLON.SceneLoader.ImportMeshAsync("", "", file, currentScene);
      if (result) {
        const loadedMeshes = result.meshes.filter(m => m.name !== "__root__");
        
        if (loadedMeshes.length) {
          // Calculate bounds for camera positioning
          const bounds = calculateModelBounds(loadedMeshes);
          currentCamera.position = new BABYLON.Vector3(
            bounds.center.x,
            bounds.center.y + bounds.size.y,
            bounds.center.z + Math.max(bounds.size.x, bounds.size.y, bounds.size.z) * 2
          );
          
          if (currentCamera instanceof BABYLON.ArcRotateCamera) {
            currentCamera.target = bounds.center;
          } else if (currentCamera instanceof BABYLON.UniversalCamera) {
            currentCamera.setTarget(bounds.center);
          }

          // Set up action managers and check for specific mesh name
          loadedMeshes.forEach(mesh => {
            mesh.actionManager = new BABYLON.ActionManager(currentScene);
            mesh.actionManager.registerAction(
              new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                () => {
                  const properties = getMeshProperties(mesh);
                  updatePropertyPanel(properties);
                        // Valentine please explain this to rohit 
      if (!mesh.chartComponent) {
        mesh.chartComponent = new ChartComponent();
        mesh.chartComponent.componentDidMount();
      }
      
      // Optional: Remove chart when clicking away from mesh
    //   currentScene.onPointerDown = function(evt, pickResult) {
    //     if (!pickResult.hit) {
    //       // Remove existing chart if clicking on empty space
    //       if (mesh.chartComponent) {
    //         const containers = document.querySelectorAll('.chart-container');
    //         containers.forEach(container => container.remove());
    //         mesh.chartComponent = null;
    //       }
    //     }
    //   };
                }
              )
            );

            // Check for specific mesh name and create overlay
            if (mesh.name === 'G-__559002_G-__559002_Material'  || mesh.name === 'G-__564519_G-__564519_Material' || mesh.name === 'G-__559191_G-__559191_Material') {
              createMeshOverlay(mesh);
              applyCustomGlow(mesh, "#00FF00"); // Green glow
              
            }

            // Check for specific mesh names and create overlays
            if (mesh.name === 'G-__564663_G-__564663_Material') {
              createRedMeshOverlay(mesh);
              applyCustomGlow(mesh, "#FF0000"); // Red glow
            }
            if (mesh.name === 'G-__562197_G-__562197_Material') {
                createOrangeMeshOverlay(mesh);
                applyCustomGlow(mesh, "#FFA500"); // Orange glow
            }

            // Add specific coloring for the new mesh
            if (mesh.name === 'G-__566166_G-__566166_Material.002') {
                // Create new green material
                const greenMaterial = new BABYLON.StandardMaterial("greenMat", currentScene);
                greenMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);     // Pure green
                greenMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                greenMaterial.emissiveColor = new BABYLON.Color3(0, 0.2, 0);  // Slight green glow
                greenMaterial.ambientColor = new BABYLON.Color3(0, 0.5, 0);   // Green ambient
                greenMaterial.specularPower = 64;
                greenMaterial.backFaceCulling = false;
                
                // Apply material to mesh
                mesh.material = greenMaterial;
                
                // Optionally add glow effect
                // applyCustomGlow(mesh, "#00FF00");
            }
          });
        }
        
        updateMeshList(loadedMeshes);
      }
    } catch (error) {
      console.error("Error loading model:", error);
      const errDiv = document.createElement("div");
      errDiv.style.color = "red";
      errDiv.textContent = "Error loading model: " + error.message;
      document.getElementById("controlPanel").appendChild(errDiv);
    }
  }
});
      
      window.addEventListener("resize", () => {
        engine.resize();
      });

      loadObjBtn.onclick = () => {
        objFileInput.click();
      };

      objFileInput.onchange = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            BABYLON.SceneLoader.ImportMesh(
                "", 
                "data:", 
                e.target.result,
                currentScene,
                function (meshes) {
                    // Center and scale model to fit view
                    const center = BABYLON.Mesh.ComputeAbsoluteCenter(meshes);
                    meshes.forEach(mesh => {
                        mesh.position = center;
                    });
                }
            );
        };
        reader.readAsDataURL(file);
      };
    });

    function getMeshBestView(mesh) {
        // Get mesh bounding info
        const boundingInfo = mesh.getBoundingInfo();
        const center = boundingInfo.boundingBox.centerWorld;
        const diagonal = boundingInfo.boundingBox.maximumWorld.subtract(boundingInfo.boundingBox.minimumWorld);
        const size = Math.max(diagonal.x, diagonal.y, diagonal.z);
        
        // Calculate camera position based on mesh size
        const offset = size * 2; // Adjust this multiplier to change the zoom level
        
        return {
            targetPosition: center,
            cameraPosition: new BABYLON.Vector3(
                center.x,
                center.y + size * 0.5, // Position slightly above center
                center.z + offset // Position back enough to see the full mesh
            )
        };
    }
  </script>
</body>
</html>


